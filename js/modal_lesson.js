const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// ctx.beginPath(); /*Метод CanvasRenderingContext2D.beginPath() Canvas 2D API запускает новый путь, опуская список подпутей. Вызовите этот метод, когда хотите создать новый путь*/
// ctx.rect(
//   20,
//   40,
//   50,
//   50,
// ); /*первые два параметра определяют координаты верхнего левого угла прямоугольника на canvas, в то время, как два других параметра определяют ширину и высоту прямоугольника.*/
// ctx.fillStyle = '#FF0000';
// /*Свойство fillStyle хранит цвет, который будет использован методом fill() для отрисовки нашего квадрата.*/
// ctx.fill();
// ctx.closePath();
// /*метод из Canvas 2D API, добавляет в путь линию от текущей до первоначальной точки под пути и закрывает сам путь (давая возможность инициализировать новый). Если путь пустой или содержит одну точку, этот метод ничего не делает. Сама функция ничего не рисует. Он лишь позволяет отрисовывать путь таким методам, как stroke() и fill().*/

// /*часть кода для отрисовки зелёного круга.*/
// ctx.beginPath();
// ctx.arc(
//   240,
//   160,
//   20,
//   0,
//   Math.PI * 2,
//   false,
// ); /*метод arc(). Он принимает шесть параметров: x и y координаты центра круга; радиус; начальный и конечный угол отрисовки круга (в радианах) направление отрисовки: (false - по часовой стрелке, по умолчанию, или true - против часовой стрелки). Последний параметр не обязательный.*/
// ctx.fillStyle = 'green';
// ctx.fill();
// ctx.closePath();

// ctx.beginPath();
// ctx.rect(160, 10, 100, 40);
// ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
// ctx.stroke(); /*Вместо fill() и заполнения фигур цветом, можно использовать stroke(), чтобы окрасить только внешнюю обводку фигуры. */
// ctx.closePath();

//1 Чтобы canvas постоянно обновлялся, необходимо определить функцию отрисовки, которая будет циклически запускаться с разными параметрами, чтобы изменять позицию элемента. Функцию можно циклически запускать с помощью JavaScript временной функции, такой как setInterval() или requestAnimationFrame().
//2 Удалите весь JavaScript код, который сейчас хранился в Вашем HTML файле, за исключением первых двух строк, и добавьте следующий код после них. Функция draw() будет исполняться внутри функции setInterval каждые 10 мс:
//3 Вы не можете определить, перерисовывается ли мяч в конкретный момент, так как его позиция не меняется. Давайте исправим это. Прежде всего, в позиции (50,50) определим стартовую точку в нижней центральной части Canvas в переменной x и y, и потом используем их для определения текущего положения мяча
let x = canvas.width / 2; // 4 Для начала добавьте следующие две строки до функции draw(), чтобы определить переменные x и y
let y = canvas.height - 30;
let dx = 2; // 6 Теперь важная часть: мы хотим добавлять небольшое значение к переменным x и y после каждой итерации, чтобы заставить мяч двигаться. Давайте определим эти небольшие значения в переменных dx и dy и установим их 2 и -2 соответственно. Добавьте следующий код после определения переменных x и y
let dy = -2;
// 11 Простое обнаружение столкновений
let ballRadius = 10; // 12 Чтобы сделать расчеты проще, давайте определим переменную ballRadius, что задаст радиус нарисованного круга и будет использоваться для вычислений.
let color = randColor(); // 17 Упражнение: попробуйте изменить цвет шарика на случайный цвет каждый раз, когда он попадает в стену.
// 18
let paddleHeight = 10; // 18.1  Здесь мы определяем высоту и ширину ракетки, и его начальную точку на оси X, для дальнейшего использования в расчетах
let paddleWidth = 75;
let paddleX = (canvas.width - paddleWidth) / 2;

let rightPressed = false; // 18.4 Значением по умолчанию для обоих является false, так как изначально кнопки не нажаты. Для прослушивания нажатий клавиш, мы создадим два обработчика событий.
let leftPressed = false;

document.addEventListener('keydown', keyDownHandler, false); // 18.4  Для прослушивания нажатий клавиш, мы создадим два обработчика событий.
document.addEventListener('keyup', keyUpHandler, false); // 18.5 Когда keydown событие вызывается любой клавишей клавиатуры (нажатием клавиши), функция keyDownHandler() будет выполняться. Та же картина верна для второго обработчика: keyup событие запустит функцию keyUpHandler () (когда будет отпущена).  блок ниже addEventListener()
// 18.6 Когда мы нажимаем клавишу, эта информация хранится в переменной. Соответствующая переменная в каждом конкретном случае устанавливается в true. Когда клавиша отпущена, переменная устанавливается обратно в false.
// Обе функции принимают параметр, представленный переменной e. Из нее вы можете получить полезную информацию: key содержит информацию о нажатой клавише. Например, код 37 — это клавиша стрелка влево и 39 — стрелка вправо. Если стрелка влево нажата, то переменная leftPressed имеет значение true, когда кнопка отпущена, то переменная leftPressed имеет значение false. Та же схема со стрелкой вправо и переменной rightPressed.

// function draw() {
//   // 5 Благодаря бесконечности функции setInterval функция draw() будет выполняться каждые 10 мс бесконечно или же пока мы не остановим её.
//   ctx.clearRect(0, 0, canvas.width, canvas.height); // 9 Мяч оставляет след, потому что мы рисуем круг на каждой итерации без удаления предыдущей отрисованной фигуры. Не переживайте, потому что существует метод для очистки canvas элемента: clearRect(). Этот метод принимает четыре параметра: x и y координаты верхнего левого угла прямоугольника, x и y координаты нижнего правого угла прямоугольника. Вся площадь, покрытая прямоугольником, будет очищена от любого содержимого, которое когда-либо было там отрисовано.
//   ctx.beginPath();
//   ctx.arc(x, y, 10, 0, Math.PI * 2); // 7 Далее обновите функцию draw(), чтобы использовать переменные x и y в методе arc()
//   ctx.fillStyle = '#0095DD';
//   ctx.fill();
//   ctx.closePath(); // код отрисовки
//   x += dx; // 8 необходимо обновить переменные x и y на значение dx и dy каждую итерацию, чтобы мяч отрисовывался каждый раз на новой позиции
//   y += dy;
// }
// setInterval(draw, 10);

// 10 Рефакторинг
// Мы будем добавлять каждый раз всё больше команд в функцию draw(), поэтому было бы неплохо содержать наш код настолько простым и понятным, на сколько это возможно. Давайте вынесем команды перемещения мяча в отдельную функцию.
// Замените существующую функцию draw() следующими двумя функциями:
function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI * 2); // 13 Теперь обновите строку, которая рисует шарик, внутри функции drawBall() :
  ctx.fillStyle = color; // 17
  ctx.fill();
  ctx.closePath();
}
// 18.2 Здесь мы определяем высоту и ширину ракетки, и его начальную точку на оси X, для дальнейшего использования в расчетах. Давайте создадим функцию, которая будет рисовать ракетку на экране. Добавьте следующий блок после функции drawBall():
function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = '#0095DD';
  ctx.fill();
  ctx.closePath();
}
// 14 Есть четыре стены, от которых мяч будет отскакивать — давайте сначала сосредоточимся на верхней. При каждом кадре нужно проверять, коснулся ли мяч верхней границы — если да, то будет обратное движение мяча, поэтому он начнет двигаться в противоположном направлении и остановится в пределах видимой границы. Вспомнив, что система координат начинается с левого верхнего угла, мы можем придумать что-то вроде этого  if(y + dy < 0) { dy = -dy;}
// Если значение y положения шара ниже нуля, изменить направление движения по оси y установив его с тем же значением но с другим знаком. Если мяч движется вверх со скоростью 2 пикселя на кадр, теперь он будет двигаться "вверх" со скоростью -2 пикселя, что на самом деле означает движение вниз со скоростью 2 пикселя. if(y + dy > canvas.height) { dy = -dy;}
// Если положение мяча по оси y больше, чем высота полотна (помните, что мы рассчитываем значения y от верхнего левого, чтобы верхний край начинался с 0, а нижний край — 480 пикселей, высота нашего <canvas>), затем после отскока от нижней кромки обратное движение по оси y.
// 15 Отскоки влево и вправо Мы сделали отражение от верхней и нижней границ, нельзя забывать и про боковины. Задача очень похожа на самом деле, все, что вам нужно сделать, это повторить конструкцию заменив Y на X:
// 16 Мяч должен отскакивать сразу после касания, а не когда он уже на половину в стене, так что давайте корректировать наш код включив в него небольшое выражение.
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBall();
  drawPaddle(); // 18.8 Единственное, что осталось сделать сейчас, это вызвать drawPaddle() функцию внутри функции draw(), чтобы нарисовать ракетку на экране. Добавьте следующую строку внутрь функции draw(), чуть ниже строки, которая вызывает drawBall():
  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
    // 16 added ballRadius
    dx = -dx;
    color = randColor(); // 17
  }
  if (y + dy > canvas.height - ballRadius || y + dy < ballRadius) {
    // 14 Мы можем объединить эти две конструкции в одну, чтобы уменьшить код Если одно из двух утверждений верно, тогда направление мяча меняется.
    dy = -dy;
    color = randColor(); // 17
  }
  x += dx;
  y += dy;

  if (rightPressed && paddleX < canvas.width - paddleWidth) {
    // 18.7 Если нажата стрелка влево, то ракетка будет двигаться на 7 пикселей влево, а если нажата стрелка вправо то на 7 пикселей вправо. Все хорошо, но, если держать клавишу слишком долго, ракетка уходит за границы холста. if(rightPressed) {paddleX += 7; }else if(leftPressed) {    paddleX -= 7;} Улучшим ситуацию, будем перемещать ракетку только в пределах холста, изменив код следующим образом:
    paddleX += 7;
  } else if (leftPressed && paddleX > 0) {
    // 18.7 Позиция paddleX будет двигаться от 0 на левой стороне холста и canvas.width-paddleWidth на правой стороне. Это будет работать именно так, как нам нужно.
    paddleX -= 7;
  }
}
// 17
// 18 Мяч беспрепятственно отражается от стен, и вы можете смотреть на него бесконечно, но в настоящее время нет интерактивности. Это не игра, если вы не можете управлять мячом. Давайте добавим взаимодействие с игрой: управление ракеткой.
// 18.3 Позволяем пользователю управлять ракеткой
// Мы можем отобразить ракетку там, где мы хотим, но она должна реагировать на действия пользователя — настало время реализовать управление с помощью кнопок. Нам понадобится:

// Две переменные для хранения информации о том, левая или правая кнопка управления нажата.
// Два слушателя для событий keydown и keyup — мы хотим запустить некоторый код для обработки движения ракетки при нажатии кнопок.
// Две функции обработки события keydown и keyup код, который будет выполняться при нажатии кнопок.
// Возможность перемещения ракетки влево и вправо
// Нажатые кнопки могут быть определены и инициализированы булевыми переменными. Добавьте эти строки рядом с остальными вашими переменными:
function randColor() {
  var r = Math.floor(Math.random() * 256),
    g = Math.floor(Math.random() * 256),
    b = Math.floor(Math.random() * 256);
  return '#' + r.toString(16) + g.toString(16) + b.toString(16);
}
function keyDownHandler(e) {
  if (e.keyCode == 39) {
    rightPressed = true;
  } else if (e.keyCode == 37) {
    leftPressed = true;
  }
}

function keyUpHandler(e) {
  if (e.keyCode == 39) {
    rightPressed = false;
  } else if (e.keyCode == 37) {
    leftPressed = false;
  }
}

setInterval(draw, 10);
